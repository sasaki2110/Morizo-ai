# Morizo AI - 自前ReActループ実装フロー

## 📋 概要

LangChainアプローチの挫折を受けて、**自前ReActループ**による動的MCPエージェントを実装。よりシンプルで制御可能なアプローチを採用。

## 🚨 緊急課題

### 在庫数量の不一致問題 ✅ **解決完了**
**優先度: 最高** ✅ **2025年9月24日解決**

**問題**: AI報告とDB実際の在庫数量に重大な不一致が発生
- AI報告: 牛乳6本
- DB実際: 牛乳9本（15件の在庫データから6個の牛乳タスクが生成）

**影響**: 
- ユーザーに誤った在庫情報を提供
- 在庫管理の信頼性に致命的な影響
- 削除・更新操作の安全性に問題

**原因分析**:
- LLMの応答が途中で切れる（max_tokens制限）
- JSON解析エラーによるフォールバック処理
- ActionPlannerのプロンプトが長すぎて応答が不完全
- **根本原因**: LLMの単純な足し算が苦手

**実施した対策**:
1. ✅ **ActionPlannerのmax_tokens増加**: 1000→1500に増加
2. ✅ **プロンプト最適化**: 在庫要約の簡潔化とプロンプト全体の簡素化
3. ✅ **LLM集計指示の強化**: 正確な集計ルールと具体例を追加
4. ✅ **フォールバック処理の改善**: 不適切なタスク生成の検出と処理

**解決結果**:
- ✅ **牛乳**: 9本（正確）
- ✅ **鶏もも肉**: 3パック（正確）
- ✅ **もやし**: 3袋（正確）
- ✅ **パン**: 3袋（正確）

**解決日**: 2025年9月24日
**ステータス**: ✅ **完全解決**

## 🚀 シンプルメッセージ処理の最適化 ✅ **2025年9月24日実現**

### LLM判断による責任分離 ✅ **実装完了**

**問題**: 挨拶などのシンプルなメッセージがReActループに流れてしまう
- 「こんにちは」→ 複雑なタスク生成 → エラー
- キーワード判定ロジックの複雑化と保守性の問題

**解決アプローチ**: LLMの自然な判断を活用
- **ActionPlanner**: LLMがJSONで応答しない場合 = シンプルメッセージと判断
- **TrueReactAgent**: 空のタスク配列 → `_generate_simple_response`に流す
- **責任分離**: 複雑なキーワード判定を排除し、LLMの判断に委ねる

**実装結果**:
- ✅ **「こんにちは」**: 直接LLM応答（自然な挨拶）
- ✅ **「今の在庫を教えて」**: 適切にReActループで処理
- ✅ **エレガントなフォールバック**: JSON解析エラーを意図的な判断として処理

### 🎯 将来の最適化可能性

**高速化＋トークン節約の可能性**: 無駄な重複したLLM呼び出しを抑止可能かもしれない

**現状の課題**:
- ActionPlannerでの`create_plan`結果がシンプルメッセージだった場合
- 現在は、TrueReactAgentにて`_generate_simple_response`で再度LLMを呼び出している

**最適化案**:
- ActionPlannerが既にシンプルな応答を生成済みの場合
- その応答をそのまま返すことで、重複LLM呼び出しを回避
- いわゆる「Final Answer判定」の実装が必要

**実装優先度**: 後の高速化・トークン節約の課題として保留

## 🎉 MCPツール拡張による問題解決の実装

### 設計思想の転換 ✅ **2025年9月24日実現**

**問題**: 一括操作要求での複雑なタスク分解とエラー発生
- 「牛乳9本全部削除」→ 9個の個別削除タスク → MCP tool error
- 「パンは冷凍したから、賞味期限をクリアしておいて」→ 複雑なタスク分解

**解決アプローチ**: MCPツール拡張による根本解決

#### 実装過程

**Step 1: 新規MCPツールの追加**
```python
# db_mcp_server_stdio.py に追加
@mcp.tool()
async def inventory_delete_by_name(token: str, item_name: str) -> Dict[str, Any]:
    """名前指定での在庫アイテム一括削除"""
    # 指定された名前のアイテムを全て削除
    # SQL: DELETE FROM inventory WHERE item_name = '牛乳'

@mcp.tool()
async def inventory_update_by_name(
    token: str,
    item_name: str,
    quantity: Optional[float] = None,
    unit: Optional[str] = None,
    storage_location: Optional[str] = None,
    expiry_date: Optional[str] = None
) -> Dict[str, Any]:
    """名前指定での在庫アイテム一括更新"""
    # 指定された名前のアイテムを全て更新
    # SQL: UPDATE inventory SET ... WHERE item_name = 'パン'
```

**Step 2: ActionPlannerの更新**
```python
# action_planner.py のプロンプト更新
planning_prompt = f"""
ルール:
- 1件更新/削除→inventory_update/inventory_delete (item_id必須)
- 一括更新/削除→inventory_update_by_name/inventory_delete_by_name (item_nameのみ)
"""
```

**Step 3: テストケースの追加**
```python
# tests/test_true_react_agent_short.py に追加
async def test_bulk_delete_by_name(self):
    """一括削除のテスト（by_name）"""
    test_case = "牛乳9本全部削除"
    # 期待: 1つのinventory_delete_by_nameタスク

async def test_bulk_update_by_name(self):
    """一括更新のテスト（by_name）"""
    test_case = "パンは冷凍したから、賞味期限をクリアしておいて"
    # 期待: 1つのinventory_update_by_nameタスク
```

#### 実装結果

**成功例**:
- ✅ **「牛乳9本全部削除」**: 1つの一括削除タスクで完了
- ✅ **「パンは冷凍したから、賞味期限をクリアしておいて」**: 1つの一括更新タスクで完了

**設計思想の勝利**:
- **従来**: 1つの引出（複雑なReActループ）で全てを処理
- **今回**: 複数の引出（専用MCPツール）で適材適所

#### 将来の拡張可能性
- **inventory_delete_by_expiry**: 賞味期限切れ商品の一括削除
- **inventory_list_by_location**: 保管場所別の在庫一覧
- **inventory_move_by_name**: 保管場所の一括移動

**実装日**: 2025年9月24日
**ステータス**: ✅ **完全解決**

## 🎯 目標

### **Phase 3: 動的AIエージェント化** ✅ **完了**
- 動的ツール選択による自然言語理解
- MCPサーバーからの動的ツールリスト取得
- ハードコーディングの完全排除
- 統一されたインターフェース

## 🚀 実装完了事項

### **1. 完全動的MCPエージェント**
- **動的ツール選択**: LLMがMCPサーバーから取得したツールリストから適切なツールを選択
- **動的ツール実行**: ハードコーディングを完全に削除し、任意のツールを動的に実行
- **動的結果整形**: LLMがすべてのツール結果を適切に整形
- **挨拶パターンの適切な処理**: 2025/9/24完了
- **不適切なタスク生成の検出とフォールバック**: 2025/9/24完了
- **プロンプト最適化とエラーハンドリング改善**: 2025/9/24完了

### **2. アーキテクチャの進化**
```
Phase 1: 基本機能 ✅
Phase 2: MCP化 ✅
Phase 3: 動的AIエージェント化 ✅
```

### **3. コードの簡素化**
- **冗長なエンドポイント削除**: `/inventory/*`エンドポイントを削除
- **不要なPydanticモデル削除**: `InventoryRequest`、`InventoryUpdateRequest`を削除
- **統一されたインターフェース**: すべての操作が`/chat`経由で実行

## 🔍 技術的な突破点

### **1. 真の拡張性の実現**
- MCPサーバーに新しいツールを追加するだけで、AIエージェントが自動的に認識・使用
- `main.py`の修正は一切不要
- ハードコーディングを完全に排除

### **2. 自然言語での在庫管理**
- 「牛乳を2本、冷蔵庫に追加して」→ `inventory_add`実行
- 「在庫を教えて」→ `inventory_list`実行
- 「2本は間違えて入力したから削除して」→ `inventory_delete`実行

### **3. ReActパターンの実装**
- **観察**: ユーザー入力の分析
- **思考**: LLMによるツール選択
- **決定**: 適切な行動の選択
- **行動**: MCPツールの実行

## ⚠️ 発見した課題

### **1. 設計の重要性**
- **付け焼刃の問題**: 在庫情報を毎回取得する対処療法は設計不足
- **CRUD操作の本質**: 単純なツール選択ではなく、文脈を理解した操作判断が必要

### **2. パラメータ抽出の複雑さ**
- **item_idの抽出**: 「2本は間違えて入力したから」から正確なIDを特定する困難
- **文脈理解**: 現在のDB状態とユーザー要求の照合が必要

## 🎯 次のステップ（設計課題）

### **Phase 4: 高度なAIエージェント化**

#### **1. MCPサーバーの再設計**
- **現在**: CRUDを別々に提供
- **提案**: 在庫更新のみを提供し、現在のDBと比較してCRUDを決定

#### **2. LLMの思考プロセス強化**
- **現在**: 単純なツール選択
- **提案**: CRUDの何に該当するかをLLMに思考させる

#### **3. 高度なパラメータ抽出**
- **現在**: 基本的なパラメータのみ
- **提案**: 文脈を理解した高度なパラメータ抽出

#### **4. レシピ提案機能の追加**
- **食材マッチング**: 現在の在庫に基づくレシピ提案
- **レシピ検索**: 外部APIとの連携
- **栄養バランス**: 栄養価の考慮

## 📁 現在のプロジェクト構成

```
/app/Morizo-ai/
├── main.py (動的MCPエージェント) ✅
├── db_mcp_server_stdio.py (MCPサーバー) ✅
├── backups/ (バックアップファイル) ✅
├── tests/ (検証プログラム) ✅
├── docs/ (ドキュメント) ✅
├── me2you/ (参考例) ✅
└── requirements.txt (依存関係) ✅
```

## 🧪 テスト方法

```bash
cd /app/Morizo-ai
source venv/bin/activate
python main.py
```

### 期待される動作
```
=== Morizo AI ReAct Agent 開始 ===
🔍 [観察] ユーザー入力: 牛乳を2本、冷蔵庫に追加して
🧠 [思考] MCPサーバーから動的にツールリストを取得中...
🧠 [思考] 利用可能なツール: 5個
🧠 [思考] LLM判断: {"tool": "inventory_add", "reasoning": "牛乳の追加要求", "parameters": {"item_name": "牛乳", "quantity": 2, "unit": "本", "storage_location": "冷蔵庫"}}
🎯 [決定] 選択されたツール: inventory_add
🔍 [行動] MCPでinventory_addを実行
✅ [成功] inventory_add実行完了
✅ [完了] 最終応答: 牛乳を2本、冷蔵庫に追加しました！
```

## 🏆 成果

**真の動的MCPエージェントの実現**

- ハードコーディングを完全に排除
- 自然言語での在庫管理が可能
- 新しいツールの追加が自動的に認識
- 統一されたインターフェース

これで**Phase 3: 動的AIエージェント化**が完了しました！次は**Phase 4: 高度なAIエージェント化**に向けて、本格的な設計を検討する段階です。

---

## 📚 参考資料

- [LangChain統合フロー](MAKINGLG.md) - 挫折したアプローチの記録
- [開発ロードマップ](ROADMAP.md) - 全体の開発計画
- [アーキテクチャ](ARCHITECTURE.md) - システム設計
- [MCP作成フロー](MAKINGMCP.md) - MCPサーバー実装手順
